# 4. 트랜잭션 관리: 사가
### 4.3.2. 비격리 대책
- 비격리로 인한 비정상을 방지하고, 비지니스에 미치는 영향을 최소화하는 방향으로 사가를 작성해야 한다.

#### 사가의 구조(3가지)
- 보상 가능 트랜잭션(compensatable transaction): 롤백 가능한 트랜잭션
- 피봇 트랜잭션(pivot transaction): 피봇 트랜잭션이 커밋되면 사가는 최종적으로 성공하거나 실패한다.
- 재시도 가능 트랜잭션(retriable transaction): 피봇 트랜잭션 이후는 완료가 보장된다. 

#### 대책
- 시맨틱 락(semantice lock): 애플리케이션 수준의 락
  - 생성/수정하는 레코드에 무조건 flag를 세팅하는 대책이다. flag를 세팅해서 다른 트랜잭션이 레코드에 접근하지 못하게 lock 을 걸어 놓거나, 다른 트랜잭션이 해당 레코드를 처리할 때 조심하라고 warning 한다. 이 flag는 
    재시도 가능 트랜잭션(사가 완료) 또는 보상 트랜잭션(사가 롤백)에 의해 해제된다.
  - 추가로 PENDING 상태의 레코드를 어떻게 사가로 처리할지 사례별로 결정해야 한다. 하나의 해결책은 블로킹하는 것이다... <span style="color: red"><- p176 이해가 안간다.</span>
  - ex) `*_PENDING` 상태 만들어서 다른 사가가 이에 맞는 행동을 하라고 알려주는 것.
- 교환적 업데이트(commutative updates): 업데이트 작업은 어떤 순서로 실행해도 되게끔 설계한다.
  - ex) 계좌에서 금액을 인출 후 에러 발생으로 보상 트랜잭션이 발생해야 하면 단순히 해당 금액만큼 다시 입금하는 업데이트를 하면 된다.   
- 비관적 관점(pessimistic view): 사가 단계 순서를 재조정해서 비지니스 리스크를 최소화한다.
  - 더티 읽기(dirty read)로 인한 리스크를 줄이는 방법이다.
  - 보상 트랜잭션이 발생하는 순서를 무조건 원래 순서의 역순으로 하는게 아니라 비지니스를 최대한 잘 파악해서 조정하는 방법이다.
- 값 다시 읽기(reread value)(낙관적인 오프라인 락(Optimistic Offline Lock):
  - 데이터를 엎어 써서 소실되는 업데이트를 방지하는 대책이다. 사가가 데이터를 업데이트하기 전에 값을 다시 읽어서 변경되었는지 확인하는 것이다.
  - ex) 주문 생성 사가가 적용하면 주문이 승인되는 도중에 취소되는 불상사를 방지할 수 있다. 주문 승인 트랜잭션은 해당 주문이 처음 생성된 이후, 이전 사가 단계에서 변경되었는지 체크를 한다. 변경되지 않았으면 주문 승인을 하고, 주문 
    취소되었다고 데이터가 변경되었으면 사가를 멈추고 보상 트랜잭션을 작동한다.
- 버전 파일(version file): 순서를 재조정할 수 있게 업데이트를 기록한다.
  - 레코드에 수행한 작업을 하나하나 기록하는 대책이다.
  - ex) 주문 생성 사가가 소비자 신용카드를 승인하기 전에 주문 취소 사가가 해당 신용카드를 승인 취소하는 순서가 안 맞는 요청을 회계 서비스가 받아서 처리해야 할 때, 작업이 도착하면 먼저 기록해 두었다가 정확한 순서대로 실행하면 된다.
- 값에 의한(by value): 요청별 비지니스 위험성을 기준으로 동시성 매커니즘을 동적으로 선택한다.
  - 애플리케이션 차원에서 각 요청의 속성을 보고 사가를 쓸지, 분산 트랜잭션을 쓸지 판단하는 것이다.
  - 위험성이 낮은 요청은 사가를 적용하고, 위험성이 큰 요청은 분산 트랜잭션을 실행한다.
