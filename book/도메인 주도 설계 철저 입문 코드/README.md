# 도메인 주도 설계 철저 입문 - 코드와 패턴으로 밑바닥부터 이해하는 DDD

## 02. 시스템 특유의 값을 나타내기 위한 '값 객체'
- 정의
    - 시스템 고유의 값을 나타내는 객체
- 값의 성질
    - 변하지 않는다.
    - 수정할 수는 없고 대입할 수는 있다.
    - 값의 속성을 꺼내 비교하는 것이 아니라 값끼리 비교한다.
- 값 객체가 되기 위한 기준(필자 개인적인 기준) # 이 부분이 잘 이해가 안 가네.
    - 규칙이 존재하는 경우
    - 낱개로 다루어야 하는 경우
- 특징
  - 행동을 가진다.
- 장점
  - 표현력이 증가한다.
    - 규칙을 값 객체 내부에 정의함으로써 코드 자체가 문서화 역할을 할 수 있다.
  - 무결성이 유지된다.
    - 예를 들어, 유효성 검사를 값 객체를 호출하는 곳에서 알아서 체크하도록 둔다면 중복된 코드가 곳곳에 흩어진다. 또한, 유효성 검사를 잘못 했을 경우 잠재적인 버그가 생길 수 있다.
  - 잘못된 대입을 방지한다.
  - 로직이 곳곳이 흩어지는 것을 방지한다.

## 03. 생애주기를 갖는 객체 - 엔티티 
- 정의
  - 도메인 모델을 구현한 도메인 객체
- 성질
  - 가변이다.
    - 엔티티의 속성은 객체의 행동을 통해 수정한다.
  - 속성이 같아도 식별자(identity)로 구분한다.
  - 동일성을 통해 구별된다.
    - equals, hashCode를 통해 비교한다.
- 값 객체 vs 엔티티 구별 판단 기준
  - 공통점
    - 모두 도메인 모델을 구현한 도메인 객체
  - 차이점
    - 엔티티: 속성과 무관한 동일성(identity)로 식별한다. 생애주기를 갖고 있다.
    - 값 객체: 변하지 않는 속성과 값으로 식별한다. 생애주기를 갖지 않거나 생애주기를 나타내는 것이 무의미하다.
- 장점
  - 자기 서술적인 코드가 된다.
  - 도메인에 변경사항이 있을 시 코드에 반영하기 쉽다.
- 특이사항
  - 같은 대상이더라도 어떤 환경에 있느냐에 따라 모델링 방법이 달라진다. 따라서, 어떤 경우에는 값 객체가 적당할 수도 있고, 어떤 경우에는 엔티티가 적당할 수도 있다.

## 04. 부자연스러움을 해결하는 도메인 서비스
- 서비스 종류
  - 도메인 서비스
  - 애플리케이션 서비스
- 도메인 서비스 정의
  - 값 객체나 엔티티로 구현하기 어색한 행위를 해결해주는 객체이다.
- 장점
  - 도메인에 정의하면 어색한 행위를 떼어내어 부자연스러움을 해결해 준다.
- 주의점
  - 도메인 객체에 정의할 행위까지 도메인 서비스에 정의하면 getter, setter만 남는 빈혈 도메인 객체가 된다. 이는 데이터와 행위를 함께 모아 놓는다는 객체지향 설계의 기본 원칙을 위반한다.
  - 도메인 객체를 통해 해당 도메인을 이해하기 어렵다.
  - 따라서, 값 객체나 엔티티로 구현할지 도메인 서비스로 정의할 지 헷갈리면 우선 값 객체나 엔티티로 정의한다.
- 유스케이스 수립하여 도메인 서비스 이해하기

## 05. 데이터와 관계된 처리를 분리하자 - 리포지토리
- 정의
  - 데이터를 저장하고 복원하는 처리를 추상화한 객체이다.
- 책임
  - 도메인 객체를 저장하고 복원하는 퍼시스턴시이다.
  - 도메인 개념으로부터 유래한 객체가 아니다. 데이터스토어를 조작하는 기술적 요소와 관련된 코드를 모아 문제를 해결하여 도메인 객체에서 코드를 분리시킨다.
- 테스트로 검증을 구현한다.
- ORM Framework에서 사용하는 객체(데이터 모델)은 도메인 엔티티와 전혀 다른 것이다.

## 06. 유스케이스를 구현하기 위한 '애플리케이션 서비스'
- 애플리케이션 정의
  - 사용자의 문제를 해결하기 위한 것이다.
- 정의
  - 유스케이스를 구현하는 객체이다.
  - 도메인 객체를 조작해서 사용자의 목적을 달성하게 이끄는 객체이다.
- **유스케이스를 수립**해야 한다.
- 주의 사항
  - 도메인 객체를 외부에 공개할지 여부는 소프트웨어의 미래를 좌우할 수 있는 큰 결정사항이다.
    - 공개할 경우 장점
      - 코드량이 준다.
      - 빠른 개발이 가능하다.
      - 단순하여 이해하기 수월하다.
    - 공개할 경우 문제점
      - 도메인 객체의 행동을 변경할 수 있는 곳이 애플리케이션 서비스에만 국한되지 않고 흩어진다.
      - 이로인해 복잡한 의존 관계가 형성된다.
      - 해결책
        - 가급적 도메인 객체를 직접 공개하지 않고, DTO(Data Transfer Object)를 만들어 반환하도록 한다.
        - 코드량이 증가하는 걸 방지하기 위해 도메인 객체를 지정하면 자동으로 DTO 를 생성해주는 도구를 사용한다.
  - 도메인 객체 변경처리할 때 개개의 정보 항목마다 별도의 유스케이스를 둘 것인지, 아니면 단일 유스케이스로 여러 항목을 한꺼번에 수정할지 경정해야 한다.
    - 해결책
      - Command 객체를 이용하면 변경사항이 발생해도 메서드의 시그니처를 바꿀 필요가 없다.
    - 에러 vs 예외
      - 변경처리할 때 에러를 반환할 경우, 클라이언트쪽에 실패에 대한 핸들링을 전적으로 위임한다. 따라서, 클라이언트측에서 의도치 않게 지나쳐 버리는 결과를 낳을 수 있다.
      - 예외를 발생시키면, 클라이언트쪽에 예외 핸들링을 강제할 수 있다. 미미한 성능저하가 발생할 수 있는데, 장단점 따져서 선택하면 된다.
  - 도메인 규칙을 기술해서는 안된다. 도메인 객체를 사용하는 역할만 한다.
    - 예를 들어, 사용자가 존재하는지 체크하는 규칙은 도메인 서비스를 활용한다. 중복 체크 규칙이 바뀔 때 도메인 서비스 내부만 변경하면 되기 때문에 호출하는 쪽에서는 수정 사항이 없다.
- 응집도가 낮은 애플리케이션 서비스
  - 해결책
    - 클래스를 분리하면 된다.
    - 패키지를 활용하여 전체적인 파악이 수월하게 한다. 아무래도 여러 클래스로 나누면 파악이 어려울 수 있는 부분을 패키지로 묶어서 해결할 수 있다.
- 인터페이스를 만들어 유연성을 높인다.
  - 클라이언트 측의 편의성이 높아진다. method signature만 정의하면 서비스 개발이 끝날 때까지 기다릴 필요 없이 구현을 시작할 수 있다.
  - 테스트하기 수월하다.
- 서비스는 가급적 무상태를 유지한다.


## 07. 소프트웨어의 유연성을 위한 의존 관계 제어
- 객체까리 협력할 때 유연한 설계를 위해 DIP(Dependency Injection Principle)을 적용한다.
- [DIP](https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84_%EC%97%AD%EC%A0%84_%EC%9B%90%EC%B9%99)
  - 객체지향프로그래밍에서 상위 계층이 하위 계층에 의존하는 전통적인 의존 관계 역전시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있다.
  - 원칙
    - 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.
    - 추상화는 세부 사항에 의존해서는 안된다. 세부 사항이 추상화에 의존해야 한다.
- 의존 관계 제어는 IoC(Inversion Of Control) Container 패턴으로 관리한다.
  - IOC Container가 의존 관계에 있는 모듈을 필요할 때 연결시켜줌으로써 해당 모듈에서는 직접 정의하지 않음으로써 유연성을 높인다.


## 09. 복잡한 객체 생성을 맡길 수 있는 '팩토리 패턴'
- 목적
  - 복잡한 객체를 생성하기 위한 복잡한 처리가 도메인에 포함되면 취지를 불분명하게 만든다. 따라서, 객체 생성 과정을 별도의 객체로 정의할 필요가 있다.
- 정의
  - 객체의 생성 과정과 관련된 지식이 정리된 객체이다.
- 팩토리의 존재감을 드러내려면
  - 도메인 모델과 도메인을 만드는 팩토리를 동일 패키지에 포함시킨다.
- 형태
  - 팩토리 역할을 하는 메소드로 존재
  - 도메인 객체를 만드는 별도 클래스로 존재
- 팩토리 필요성을 나타내는 좋은 지표
  - 생성자 메서드 안에서 다른 객체를 생성한다면 팩토리가 필요한지 생각하면 좋을 것
  - 생성자 메서드가 너무 복잡할 때 팩토리를 사용할 수 있음.
- 생각할 점
  - 그냥 하던 대로 객체를 생성하지 말고, 팩토리가 필요하지 않은가 검토하는 습관을 들리기


## 11. 애플리케이션 밑바닥부터 만들기
- 과정
  - 어떤 기능이 필요한가
  - 위 기능에 기반이 될 유스케이스 추출하기
  - 애플리케이션에 필요한 지식을 추출해 도메인 객체를 정의하기
  - 실제 기능으로 제공할 애플리케이션 서비스를 구현하기
- 기능에 대한 로직은 도메인에 포함되어야 함. 이게 도메인 서비스에 흩어지다보면 중복된 코드가 남아 있어서 이를 해결하기 위해서 애그리게이트(aggregate) 개념이 적용할 수 있다. 