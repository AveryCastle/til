# 소프트웨어 아키텍처(The Hard Parts)
- 이 책은 시간이 흐름에 따라 소프트웨어 개발 생태계가 변하기 때문에 특정 기술이나 상세 구현에 집중하는 대신, 아키텍트가 어떻게 의사결정을 내리는지, 새로운 상황에 처했을 때, 트레이드오프를 어떻게 객관적으로 평가할 것인지 집중한다.

## 1장. '베스트 프랙틱스' 가 없다면?
**아키텍트**
- 아키텍트는 일반적인 문제보다는 새로운 상황에서 창의적인 의사 결정을 하느라 끊임없이 고군분투하는 사람들.
- 소프트웨어 아키텍처에서 나쁜 것중에서 제일 나은 트레이드오프 조합을 찾는 걸 권장한다.

### 1.4. 아키텍처 결정 레코드(Architecture Decision Records)
#### ADR(Architecture Decision Records)
- 아키텍처 결정이 기록된 (보통 한두 페이지 정도의) 짧은 텍스트 파일.
- 보통 아시키독(AsciiDoc)이나 마크다운(Markdown) 같은 텍스트 문서 포맷이나 위키페이지의 템플릿으로 작성함.
- 포맷
  - **콘텍스트(Context)**: ADR가 다루는 문제를 한두 문장으로 간략히 기술하고 문제를 해결할 수 있는 대안을 열거한다.
  - **결정(Decision)**: 확정된 아키텍처 결정과 그렇게 결정하게 된 사유를 자세히 밝힌다.
  - **결과(Consequence)**: 아키텍처 결정이 적용되면 어떤 결과가 발생하는지, 어떤 트레이드오프를 고려해야 하는지 기술한다.

### 1.5. 아키텍처 피트니스 함수
- 아키텍처 거버넌스: 아키텍트가 정의한 설계 원칙대로 개발자가 올바르게 구현하고 있는지 관리/감독하는 것

#### 1.5.1 피트니스 함수 사용하기
**아키텍처 피트니스 함수(Architecture Fitness Function)**
- 어떤 아키텍처 특성이나 그것들을 조합한 아키텍처 특성의 무결성을 객관적으로 평가하는 임의의 매커니즘
- 사용 예제
  - [JDpend](https://github.com/clarkware/jdepend) 메트릭(지표) 도구로 패키지 간 의존성을 확인할 수 있다.
  - [소나큐브(SonarQube)](https://www.sonarsource.com/products/sonarqube/)를 이용하여 많은 공통 피트니스 함수를 턴키 방식<sup>[1](#footnote_1)</sup>으로 제공한다.
  - [아크유닛(ArchUnit)](https://www.archunit.org/)을 이용하여 거시적인 아키텍처 구조를 검증할 수 있다.

<!-- 1장.-->
<a name="footnote_1">1</a>: 제품에 기본 제공된 함수를 바로 사용할 수 있는 형태

## 2장. 따로 떼어놓기
**커플링(Coupling)**
- 소프트웨어 시스템의 어느 한쪽을 변경하면 다른 쪽도 함께 변경해야 할 경우, 양쪽은 서로 결합된(coupled) 것이다.

### 2.1. 아키텍처 퀀텀
#### 아키텍처 퀀텀(Quantum)
- 각기 다른 요소들이 서로 연결을 맺고 통신하는 방법에 관한 소프트웨어 아키텍처의 토폴로지와 동작
- 개별 배포 가능한 단위

#### 정적 커플링
- 정적인 디펜던시가 아키텍처에서 계약을 통해 어떻게 결정되는지 나타냄
- 운영체제, 프레임워크, 전이적 디펜던시 관리(transitive dependency)<sup>[2-1](#footnote_2_1)</sup>를 통해 전달되는 라이브러리 등

#### 동적 커플링
- 퀀텀이 런타임에 어떻게 서로 통신하는지(예, 동기 통신, 비동기 통신)를 나타냄. 
- 피트니스 함수를 통해 모니터링해야 함.

#### 의미
- 독립적으로 배포 가능
- 높은 기능 응집도
- 높은 정적 커플링
- 동적 퀀텀 커플링
  - 통신(Communication): 동기 통신 vs 비동기 통신
  - 일관성(Consistency): 원자성 vs 최종 일관성, 데이터 트랜잭션
  - 조정(Coordination): 오케스트레이션 방식 vs 코레오그래피 방식
  - <figure><img src="images/3차원_동적_퀀텀_커플링_그래프.png" alt=""><figcaption>그림. 3차원_동적_퀀텀_커플링_그래프</figcaption></figure>

<!-- 2장.-->
<a name="footnote_2_1">2-1</a>: A->B에 의존하고, B->C에 의존할 경우, 결과적으로 A->C에 의존하게 되는 현상


## 3. 아키텍처 모듈성
### 3.1 모듈화 동인
- 아키텍트는 뚜렷한 비지니스 동인(예. 시장 출시 속도, 시장 경쟁 우위 등) 없이 시스템을 더 잘게 나누면 안된다.

### 아키텍처 주요 5가지 특성
- 가용성(내고장성), 확장성, 배포성, 시험성, 유지 보수성 

#### 3.1.1. 유지 보수성

#### 3.1.2 시험성
- 아키텍처 민첩성을 위한 필수 성분
- 테스트의 완전성과 (보통 자동화 테스트를 통한) 용이함을 의미함.
- 예시. 서비스를 A, B, C로 나누었더라도 A -> B, B -> C, C -> 식으로 통신을 하게 되면 A가 변경되었을 때, B, C 모두 테스트해야 하기 때문에 테스트 용이성 및 완전성이 떨어지게 된다.

#### 3.1.3 배포성
- 배포의 용이함은 물론이고 배포 민도와 전체 리스크까지 포괄한 개념
- 만약, 마이크로서비스를 특정 순서를 지켜 완전한 하나의 세트로 배포해야 한다면 다시 모놀리스로 간 것과 마찬가지다.

#### 3.1.4 확장성
- 유저 부하가 점점 증가해도 시스템이 응답성을 유지하는 능력

#### 3.1.5. 가용성/내고장성
- 내고장성(fault tolerance): 아키텍처 모듈화 관점에서 시스템의 어떤 파트가 고장나도 나머지 파트는 응답성과 가용성을 유지하는 능력


## 6장. 운영 데이터 분리
### 6.1 데이터 분해인
#### 6.1.1 데이터 분해인
- 데이터 분해는 어떤 경우에 고려해야 하는가?
  - 변경 관리: 데이터베이스 테이블 변경 시 얼마나 많은 서비스가 영향을 받는가?
  - 커넥션 관리: 데이터베이스가 여러 분산 서비스와 커넥션을 맺을 수 있는가?
  - 확장성
  - 내고장성
  - 아키텍처 퀀텀
  - 데이터베이스 유형 최적화
- **변경 관리**
  - 경계 콘텍스트(Bounded Context)로 분해하면 변경 관리에 유익함.
  - 데이터 쓰기의 주체가 소유자이다.
  - 경계 컨텍스트 내에 있는 시스템의 데이터베이스가 변경되도 외부에 있는 시스템은 변경으로부터 격리된다.
- **커넥션 관리**
  - 여러 서비스가 데이터베이스 커넥션을 몇 개 맺고 있는지 따져 보며, 메트릭을 수집하는 피트니스 함수를 활용하여 파악한다.
- **확장성**
  - 데이터베이스를 포함하여 시스템 전 부문의 확장을 살펴봐야 한다.
- **내고장성**
  - 서비스나 데이터베이스가 고장이 나도 시스템의 다른 부분은 중단 없이 가동시킬 수 있어야 한다.
  - 단일 장애점(Single Point of Failure) 을 제거할 수 있다.
- **아키텍처 퀀텀**
  - 서비스 A,B 와 서비스 C,D,E 가 필요한 아키텍처 요건이 다른 상태인데 동일한 데이터베이스를 바라보면 단일 퀀텀이 된다. 따라서 이런 경우에는 서비스 A,B가 접속하는 데이터베이스와 서비스 C,D,E가 접속하는 데이터베이스를 분리하는 것이 나을 수 있다.
- **데이터베이스 타입 최적화**
  - 
